# [矫正环形链表](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

![image-20240802161209261](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202408021612520.png)

对于链表来说，成环是一件特别麻烦的事。本项目的需求就是矫正一个已经成环的链表。

## 思路一



### 算法一

- 本算法依赖于项目《寻找环形链表》，请事先阅读相关文档。

- 本算法较为抽象，故采用先证明，再写代码的顺序说明

题设：

现有一链表，其节点个数为N。为便于表述，下文将这N个节点依次编号为[0,1,2,3,4……N-2,N-1]。已知，该链表中存在环，入环的第一个节点编号为R。规定一单位为两个节点的间隔。已知，指针`fast`每次移动两个单位，指针`slow`每次移动一个单位。

问：该链表一共多少单位，没有成环部分多长单位。成环部分多长单位？

易知，对于不成环，有N个节点的链表其长度为N-1个单位，而成环链表的尾节点不像不成环链表那样指向空，而是指向成环部分的第一个节点，所以对于题设的链表来说，其长度是N个单位；成环部分的第一个节点是[R]，所以不成环部分长度为R个单位。现在链表总单位和链表不成环部分单位都已知，所以成环部分单位为N-R。

问：在`slow`指针刚进入环部分，即指向节点[R]时，指针`fast`移动了多少单位，指向的节点编号为多少？

当`slow`刚指向节点`R`时，其已经迭代了R次，由于`fast`和`slow`是同步迭代的，所以`fast`也迭代了R次，而`fast`每次迭代移动两个单位，所以此时`fsat`已经移动了2*R个单位；则此时`fast`指向的节点编号为[2\*R+K(N-R)]，其中K∈Z，即`fast`指向节点编号表达式为[$ 2R \mod{R-N}$]。

问：当`slow`刚进入环时，从`fast`到`slow`相差了多少单位？

此时`slow`指向的节点编号为[R]，`fast`指向的节点编号为[2\*R+K(N-R)]，其中K∈Z，所以它们之间相差的单位为N-R-[2\*R+K(N-R)]=N-2*R+K(N-R)=K(N-R)-R，又或者可以用$-R \mod{N-R}$来表示。

问：`fast`和`slow`最终相遇的节点（下文称为`meet`）编号为多少？

由于`slow`每迭代一次移动一个单位，`fast`每迭代一次移动两个单位，所以`fast`和`slow`在进入环后，每迭代一次后它们就会靠近一个单位，又知，当`slow`刚进入环时，从`fast`到`slow`相差了K(N-R)-R个单位，所以再迭代K(N-R)-R次后，`slow`and`fast`就会相遇，又`slow`每迭代一次移动一个单位，所以`meet`的编号为[R-R+K(N-R)]，即$0 \mod {N-R}$。

问：`meet`再移动多少单位会到达入环的第一个节点？

已知`meet`的编号为[K(N-R)]，整个链表的单位为N，所以`meet`再移动N-A(N-R)+B(N-R)=N+K(N-R)=N-(N-R)+K(N-R)=R+K(N-R)次后会到达入环的第一个节点，用含模的表达式表示就是$R \mod{N-R}$。

问：如果从链表首节点，即编号为[0]的节点开始，移动多少单位会到达入环的第一个节点？

易知，为R。

算法得证。

下面举一个例子来说明，

现在有一个链表，一共有11个节点，为了方便起见，将节点数值域中存储的数据视为节点的编号，其中节点[6]是入环的第一个节点：

![绘图1](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202408061641643.png)

可以很容易地看出，它一共有10个单位，其中不成环区域6个单位，成环部分4个单位

现在用人脑运行运行《寻找环形链表》中的代码：

| 迭代次数 |   slow    |   fast    |    备注     |
| :------: | :-------: | :-------: | :---------: |
|    1     | [0]->[1]  | [0]->[2]  |             |
|    2     | [1]->[2]  | [2]->[4]  |             |
|    3     | [2]->[3]  | [4]->[6]  |             |
|    4     | [3]->[4]  | [6]->[8]  |             |
|    5     | [4]->[5]  | [8]->[10] |             |
|    6     | [5]->[6]  | [10]->[7] | 相差4个单位 |
|    7     | [6]->[7]  | [7]->[9]  | 相差3个单位 |
|    8     | [7]->[8]  | [9]->[6]  | 相差2个单位 |
|    9     | [8]->[9]  | [6]->[8]  | 相差1个单位 |
|    10    | [9]->[10] | [8]->[10] |    meet     |

11-6等于5,[5]在环里吗？不在，[10]在环里吗，在，是不是就是在[10]相遇。

从[0]到[6]相差6个单位，从meet到[6]相差1个单位，当从[0]开始的指针到达[6]时，从meet开始的指针在到达[6]后又转了一圈回到了[6]，所以这两个指针最终在入环的第一个节点相遇。

下面是`leetcode`的答案

```c
struct ListNode* detectCycle(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    struct ListNode* meet = NULL;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (fast == slow) {
            meet = fast;
            break;
        }
    }
    if (meet == NULL) {
        return NULL;
    } else {
        fast = head;
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
}
```

当然 ，我们的项目是再修正成环部分，但既然已经找到入环的第一个节点了，大不了再遍历一次，看哪个节点的`next`等于入环第一个节点，等于再修改成空就行了。

### 算法二

~~这个算法也是在meet的基础上进行的，在相遇之后，先存储meet和meet下一个节点的地址，然后把meet的next置为空，此时，就相当于生成了两条相交的节点，然后就可以按照《判断相交链表》的方法操作，找到合并的那个节点，最后再恢复之前被破坏的meet节点。大致思路是，先创建两个指针，一个指向meet，一个指向meet->next，然后把这两个指针视为两个链表的表头，都先遍历一次，从而找出相差的节点个数，然后再回到各自的表头，让节点个数多的先走，节点个数少的后走，每次迭代都只移动一个单位，如果两个指针指向的地址相同，那这个地址就是合并的那个节点。~~

算法二不具有可行性。因为这是单链表，不能倒着走，而且由于其具有公共节点的事实，链表倒置算法无法使用。

不带头单向环形链表在meet处剪开后变成两个相交的不带头单向非环形链表，由于这是单向的，所以无法倒着遍历，就找不到第一个公共节点，也就找不到第一个入环的节点。即使有倒置算法，可以让链表逆置，但因为它们有公共节点，所以逆置一个就会影响另一个链表，导致另一个链表无法逆置。



