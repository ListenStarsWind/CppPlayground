# [构建二叉树](https://www.nowcoder.com/share/jump/9209693051725070969113)

![image-20240831114606321](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202408311146745.png)

这道题写的有些汗流浃背。出了一些问题，下面会对这些问题逐个说明。

最初，构造函数`BTBuild`并没有采用使用下标引导参数`pCurent`的方式访问数组，而是使用二级指针来访问数组，但在使用二级指针的时候，出现了后置加加和解引用操作顺序颠倒的问题，修改为`(*ppVal)++`后，问题得到了解决

`BTBuild`中的`if`部分最初并没有`(*pCurrent)++;`,从而造成递归无法停止，栈溢出的问题，第一次修改是直接把`pVal[*pCurrent]`改为`pVal[(*pCurrent)++]`,但很快发现，这样做会丢失部分数据，于是改为了现在的形式。

最初在定义`InOrder`的子函数`_InOrder`时，随手将子函数的返回类型定义为`pBTData`，母函数的返回形式为`return  _InOrder(pRoot, pArray, &i);`，后来在写子函数停止条件的时候，察觉到不对劲，于是将子函数的返回类型定义为`void`，母函数的返回形式定义为`return pArray;`但并没有添加`_InOrder(pRoot, pArray, &i);`这一行，导致返回的数组为随机值。

下面的不是错误，而是改进。

最初，构造函数中并没有第三个参数`null`，这使得空的定义被写死了，调整之后，调用者可以自己去定义什么样的数据才是空。

对`BTBuild`添加了注释，用于说明注释项。

后续若要复用，请从VS处复制，牛客的代码不是最终代码。

理论上，凡是以数组作为参数的函数，都应有一个参数用于描述数组的大小，从而避免越权访问系列问题的发生，但在此项目中，`BTBulid`并没有这种参数，这主要出于两个方面的考虑：

- 当调用者输入的数组正确（确实是某个二叉树前序遍历得到的结果）时，`BTBulid`会自动回弹至调用函数。可以自己画画图来理解。
- 当调用者输入的数组错误时，即使通过数组大小参数检查到了错误，也无法进行有效的补救，或者说，补救措施非常繁琐。（有效的补救指的是让函数返回一个正确的二叉树，补救措施是指对之前已经开辟的内存块进行释放，避免内存泄露。）

-------

上面的方法其实是用二叉树的前序遍历结果反向构建二叉树，对于中序和后序来说，由于无法区分空子树到底是谁的子树，所以是无法构建出二叉树的。除了这个局限性之外，这种方法还必须写出空才行。

下面我们会说说如何通过不带有空的遍历结果构建二叉树，当然，此时需要的遍历结果不止一个，目前我们只是稍微过一下判断过程，具体代码将在C++阶段学习。

首先看这道题：

已知某二叉树先序遍历为：EFHIGJK；中序遍历为HFIEJKG，请画出这个二叉树。

这种题目是没有标注空节点的。这类题目的思路都是一样的：用先序或者后序确定根节点，然后再用中序明确左右关系。

首先根据先序，可以确定这棵树的根节点为[E]，由于中序是左子树 根节点 右子树，所以可以确定[H]\[F]\[I]是左子树中的节点，[J]\[K]\[G]  是右子树的节点；接下来通过先序可以得知左子树的根节点为[F]，同理，再通过中序可以得知[H]为左子树的左子树根节点，而[I]为左子树的右子树的根节点，于是左子树就完全构建好了；接下来看右子树部分，根据先序可以确定右子树的根节点为[G]，又因为[J]\[K]\[G]是右子树的中序，所以可知[J]\[K]在右子树的左子树中，再由先序可以得知，这个右子树的左子树的根节点为[J],然后再根据这棵树的中序是JK，所以[K]是[J]的右子树根节点。

下一道：

已知某二叉树中序遍历为：badce；后序遍历为bdeca，请画出这个二叉树。

首先根据后序，可以得知根节点为[a]，由于左子树就一个节点，所以[b]就是左子树的根节点；接下来看右子树，根据后序，可以知道，右子树的根节点为[c]，那这也不用看了，右子树的中序是dce，而[c]又是根节点，所以[d]是右子树的左子树根节点，而[e]是右子树的右子树的根节点。

# 完