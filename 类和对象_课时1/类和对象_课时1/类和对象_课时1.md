# 类和对象_课时1

C语言是面向过程的。它将问题拆成不同的过程，通过一个个函数实现，从而解决问题；而C++则是基于面向过程的，它对问题的主要解决思路是抓住问题中涉及的对象，用对象之间的交互解决问题。当然，为了兼容C，C++也可以面向过程，实际上，C++的项目一般都是面向对象和面向过程混着用的。

## 类的引入

在C语言中，结构体只能定义变量，而在C++中，结构体被扩展成类的一种；一方面，C++中的结构体既可以向C兼容，可以创建结构体变量；更多情况下，C++中的结构体被视为类。其中类体中的内容称为类的成员：其中的变量称为类的属性或者成员变量，其中的函数称为类的方法或成员函数。同一个类下，成员函数可以直接使用成员变量（因为类的范围是确定的，所以它会在类域中全局搜索）。

下面我随手写一个栈，由于我们对C++的了解还不够充分，所以下面的代码可能有些不伦不类，仅作教学示范。为了更好地进行区分，类中的成员变量名最好有特别风格，比如我这里的风格是前面加下划线。

```c++
#include<stdlib.h>
#include<iostream>
#include<stdbool.h>

namespace wind
{
	typedef int stack_data, * p_stack_data;
	struct stack
	{
		// member function
		void Init()
		{
			_p = nullptr;
			_top = _capacity = 0;
		}

		void Dest()
		{
			free(_p);
			_p = nullptr;
			_top = _capacity = 0;
		}

		void Ext()
		{
			int newCapacity = _capacity == 0 ? 2 : _capacity * 2;
			p_stack_data p = (p_stack_data)realloc(_p, sizeof(stack_data) * newCapacity);
			if (p == nullptr)
			{
				perror("stack.Ext realloc fail");
				return;
			}
			_p = p;
			_capacity = newCapacity;
		}

		void push(stack_data val)
		{
			if (_top == _capacity)
			{
				Ext();
			}
			_p[_top++] = val;
		}

		bool IsEmpty()
		{
			if (_top == 0)
				return true;
			else
				return false;
		}

		bool ReadTop(stack_data& val)
		{
			if (IsEmpty())
				return false;
			else
			{
				val = _p[_top - 1];
				return true;
			}
		}

		bool Pop()
		{
			if (IsEmpty())
				return false;
			else
			{
				_top--;
				return true;
			}
		}

		bool ReadPop(stack_data& val)
		{
			if (IsEmpty())
				return false;
			else
			{
				ReadTop(val);
				return Pop();
			}
		}

		// member variable
		p_stack_data _p;
		int _top;
		int _capacity;
	};
}


int main()
{
	wind::stack s;
	s.Init();
	int Array[] = { 2,4,6,8 };
	for (auto tem : Array)
	{
		s.push(tem);
	}
	while (!s.IsEmpty())
	{
		wind::stack_data val;
		s.ReadPop(val);
		std::cout << val << " ";
	}
	std::cout << std::endl;
	s.Dest();
}
```

![image-20240922194721324](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409221947540.png)

## 访问限定符

在上面的例子中，我们使用`struct`定义了类，但实际上，C++对类的定义更多使用的是`class`关键字，由`struct`定义的类更多是出于为了兼容C中结构体而做出的妥协。它们之间是具有区别的。

在说它们的区别之前，我们先要了解访问限定符。为了对类中的成员进行有效的管理，C++引入了访问权限的概念。对于一个类的成员，其访问权限分为三种：public（公有）protected（保护）private（私有）。public修饰的成员在类外可以直接被访问  ；protected和private修饰的成员在类外不能直接被访问(从这个角度来看，protected和private是类似的)  ；访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止  ；如果后面没有访问限定符，作用域就到"}"即类结束。访问限定符可以将类的接口公共化，规范化，保护类中对象的内部状态，减少因调用者直接操纵对象而引发的种种问题，可以提高代码的安全性。所以我们说C++是基于面向对象的，我们不用关心类中各个过程的具体实现细节，只需要关心这些类怎么交互。

如果把上面代码的`struct`换成`class`，就会发现，代码跑不动了。这是因为`class`中的成员默认为私有权限，而`struct`为了兼容结构体，成员默认为公有权限。所以当把`struct`换成`class`，外界就无法访问类中成员了。

```c++
namespace wind
{
	typedef int stack_data, * p_stack_data;
	class stack
	{
	public:
		// member function
		void Init()
		{
			_p = nullptr;
			_top = _capacity = 0;
		}

		void Dest()
		{
			free(_p);
			_p = nullptr;
			_top = _capacity = 0;
		}

		void Ext()
		{
			int newCapacity = _capacity == 0 ? 2 : _capacity * 2;
			p_stack_data p = (p_stack_data)realloc(_p, sizeof(stack_data) * newCapacity);
			if (p == nullptr)
			{
				perror("stack.Ext realloc fail");
				return;
			}
			_p = p;
			_capacity = newCapacity;
		}

		void push(stack_data val)
		{
			if (_top == _capacity)
			{
				Ext();
			}
			_p[_top++] = val;
		}

		bool IsEmpty()
		{
			if (_top == 0)
				return true;
			else
				return false;
		}

		bool ReadTop(stack_data& val)
		{
			if (IsEmpty())
				return false;
			else
			{
				val = _p[_top - 1];
				return true;
			}
		}

		bool Pop()
		{
			if (IsEmpty())
				return false;
			else
			{
				_top--;
				return true;
			}
		}

		bool ReadPop(stack_data& val)
		{
			if (IsEmpty())
				return false;
			else
			{
				ReadTop(val);
				return Pop();
			}
		}

	private:
		// member variable
		p_stack_data _p;
		int _top;
		int _capacity;
	};
}


int main()
{
	wind::stack s;
	s.Init();
	int Array[] = { 2,4,6,8 };
	for (auto tem : Array)
	{
		s.push(tem);
	}
	while (!s.IsEmpty())
	{
		wind::stack_data val;
		s.ReadPop(val);
		std::cout << val << " ";
	}
	std::cout << std::endl;
	s.Dest();
}
```

现在也可以正常运行了。如果成员变量设置为公有，可能会有人使用`_p[_top]`的方式取栈顶元素。  

当然，实际开发过程我们肯定不是都写一个文件里的，而是声明定义写在不同的文件中：

```c++
// stack.h
#pragma once
#include<stdlib.h>
#include<iostream>
#include<stdbool.h>

namespace wind
{
	typedef int stack_data, * p_stack_data;
	class stack
	{
	public:
		// member function
		void Init();
		void Dest();
		void Ext();
		void push(stack_data val);
		bool IsEmpty();
		bool ReadTop(stack_data& val);
		bool Pop();
		bool ReadPop(stack_data& val);

	private:
		// member variable
		p_stack_data _p;
		int _top;
		int _capacity;
	};
}

// stack.cpp
#include"stack.h"

void wind::stack::Init()
{
    _p = nullptr;
    _top = _capacity = 0;
}

void wind::stack::Dest()
{
    free(_p);
    _p = nullptr;
    _top = _capacity = 0;
}

void wind::stack::Ext()
{
    int newCapacity = _capacity == 0 ? 2 : _capacity * 2;
    p_stack_data p = (p_stack_data)realloc(_p, sizeof(stack_data) * newCapacity);
    if (p == nullptr)
    {
        perror("stack.Ext realloc fail");
        return;
    }
    _p = p;
    _capacity = newCapacity;
}

void wind::stack::push(stack_data val)
{
    if (_top == _capacity)
    {
        Ext();
    }
    _p[_top++] = val;
}

bool wind::stack::IsEmpty()
{
    if (_top == 0)
        return true;
    else
        return false;
}

bool wind::stack::ReadTop(stack_data& val)
{
    if (IsEmpty())
        return false;
    else
    {
        val = _p[_top - 1];
        return true;
    }
}

bool wind::stack::Pop()
{
    if (IsEmpty())
        return false;
    else
    {
        _top--;
        return true;
    }
}

bool wind::stack::ReadPop(stack_data& val)
{
    if (IsEmpty())
        return false;
    else
    {
        ReadTop(val);
        return Pop();
    }
}

// main.cpp
#include"stack.h"

int main()
{
	wind::stack s;
	s.Init();
	int Array[] = { 2,4,6,8 };
	for (auto tem : Array)
	{
		s.push(tem);
	}
	while (!s.IsEmpty())
	{
		wind::stack_data val;
		s.ReadPop(val);
		std::cout << val << " ";
	}
	std::cout << std::endl;
	s.Dest();
}
```

为什么函数定义必须要有`类名::`，这是为了让函数意识到自己里面的`_p, _top, _capacity`是类中的成员变量。

## 类的实例化

和结构体一样，类中的成员变量必须通过类变量来访问。为了方便考虑，我们假设上述栈的成员变量全都是公有属性，此时无法通过`stack::_top`或者说`stack._top`的方式访问类中的成员变量，stack只是一个类而已，它是一套声明，或者说一套模版，它不是实实在在的变量（对象），只有真正创建了类的变量（对象），`stack s;`才能对这个变量（对象）里的成员变量进行访问（公有的话）。创建类对象的过程就叫做类的实例化。

## 类对象的存储

对于一个类对象或者已经被实例化的类来说，它们的成员变量是独立存储的，而成员函数是共有的。这很好理解，不同的类对象中的成员变量是相互独立的，互不影响的，但它们所使用的函数都是同一套的，所以类对象的实际大小和成员变量的大小有关，这里说有关是因为类和结构体类似，也存在内存对齐。

```c++
int main()
{
	wind::stack s;
	s.Init();
	int Array[] = { 2,4,6,8 };
	for (auto tem : Array)
	{
		s.push(tem);
	}
	while (!s.IsEmpty())
	{
		wind::stack_data val;
		s.ReadPop(val);
		std::cout << val << " ";
	}
	std::cout << std::endl;
	std::cout << sizeof(s) << std::endl;
	s.Dest();
}
```

![image-20240922213233064](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409222132213.png)



# 完