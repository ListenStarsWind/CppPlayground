# 类和对象_课时2

## 类中的六个默认函数

对于任何一个类来说，都会有六个默认函数。什么叫默认函数，就是如果你不写，编译器会自动生成，如果你写了，编译器就会用你写的默认函数，而不自动生成。

### 构造函数和析构函数

#### 构造函数

构造函数虽然名为“构造函数”，但它的主要职责并不是开辟成员变量的空间，对于C++的内置类型（int char double 等以及所有的指针类型【即使是类的指针类型】），都由编译器自动开辟空间（因为它们的大小都是确定的，short是两个字节，int可能由于历史原因，既有四个字节的版本，也有两个字节的版本，对于我们搞通用计算机编程的而不是搞嵌入式计算机编程的，都是四个字节······只要位数确定，不管是什么指针，大小都是确定的，64位下所有指针都是八字节）。那构造函数主要是干什么的呢？它主要是用于给成员变量初始化的，至于为什么叫做“构造函数”，那可能是翻译问题，毕竟是英语母语国家创建出的C++，然后“构造函数”这个名字一直都这样说，将错就错，改不回来了；当然，如果成员变量不是内置类型，比如一个栈什么的，那你可以顺手开辟一下空间，或者在插入数据的时候开空间，甚至如果那个栈本身的构造函数完善的话，你可以不写构造函数，让编译器自动生成，等会我们会细说一下编译器自动生成默认函数的基本逻辑，但在此之前，先让我们看看我们自己写的默认函数。

我们还是用上节课时里的类`Date`来做实验

在不初始化（没有`D.Init();`）时，打印对象内容，发现是随机值。

![image-20240925115257897](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409251152041.png)

在自己写构造函数时，要注意一些细节，构造函数的名字和类名相同，构造函数身为函数，也支持重载缺省等用法，另外要特别注意，构造函数无返回值，这里的无返回值指的不是`void`，而是真的什么都不写。如果要传参的话，就直接把对象当成构造函数来用，不传参的话，就不要带括号。

```cpp
// 我就不展示声明了
wind::Date::Date()
{
	std::cout << "正在调用构造函数“Date”-2" << std::endl;
	_year = 2;
	_month = 2;
	_day = 2;
}

wind::Date::Date(int year, int month, int day)
{
	std::cout << "正在调用构造函数“Date”-1" << std::endl;
	_year = year;
	_month = month;
	_day = day;
}

int main()
{
	wind::Date d1(1, 2, 3);
	wind::Date d2;
	d1.Print();
	d2.Print();
	return 0;
}

// 写成这样“Date d1();”会有歧义，可以把它视为返回Date类型函数的声明，也可以视为实例化某个对象
```

![image-20240925130425706](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409251304835.png)

观察汇编，可以发现，在对类进行实例化时，编译器会自动调用构造函数。

```assembly
	wind::Date d1(1, 2, 3);
00007FF76B9F1CCE  mov         r9d,3  
00007FF76B9F1CD4  mov         r8d,2  
00007FF76B9F1CDA  mov         edx,1  
00007FF76B9F1CDF  lea         rcx,[d1]  
00007FF76B9F1CE3  call        wind::Date::Date (07FF76B9F146Fh)  
00007FF76B9F1CE8  nop  
	wind::Date d2;
00007FF76B9F1CE9  lea         rcx,[d2]  
00007FF76B9F1CED  call        wind::Date::Date (07FF76B9F146Ah)  
00007FF76B9F1CF2  nop  
```

也可以合并它们，写成全缺省函数

```cpp
namespace wind
{
	class Date
	{
	public:
		Date(int year = 1, int month = 1, int day = 1);
		void Init(int year, int month, int day);
		void Print();
	private:
		int _year;
		int _month;
		int _day;
	};
}

wind::Date::Date(int year, int month, int day)
{
	std::cout << "正在调用构造函数“Date”-1" << std::endl;
	_year = year;
	_month = month;
	_day = day;
}
```

![image-20240925131122643](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409251311741.png)

好的，接下来让我们把目光转回栈，现在我们已经把`Init`用`stack`替代掉了，让我们看看能不能对`stack`作进一步优化

```cpp
wind::stack::stack()
{
    _p = nullptr;
    _top = _capacity = 0;
}
```

这种构造函数没有开辟空间，这意味着，在插入第一个数据的时候，它会进入`Ext`函数，先开辟出可以容纳四个元素的空间

```cpp
void wind::stack::Ext()
{
    int newCapacity = _capacity == 0 ? 2 : _capacity * 2;
    p_stack_data p = (p_stack_data)realloc(_p, sizeof(stack_data) * newCapacity);
    if (p == nullptr)
    {
        perror("stack.Ext realloc fail");
        return;
    }
    _p = p;
    _capacity = newCapacity;
}
```

在学习数据结构时，我们就已经说了这种扩容机制的劣势：由于栈最开始可以容纳的元素是定死的，比如说，这里就是零，当数据量很大时，`realloc`就很容易进行异地扩容，异地扩容涉及到数据的移动，增加了不少复杂度。接下来我们会利用缺省函数，对构造函数进行优化，允许用户在实例化对象时，先估算一下数据量，然后在构造函数这里就直接开辟相应大小，减少扩容的可能。如果用户不输入参数，我就先开辟4个元素的空间。如果用户待插入的数据就是堆上的数组，我们也允许用户直接把这个数组挂载到堆上，当然，此时的`sz`参数不能是估算。

```cpp
namespace wind
{
	typedef int stack_data, * p_stack_data;
	class stack
	{
	public:
		stack(size_t sz = 4, p_stack_data pArr = nullptr);
		void Dest();
		void Ext();
		void push(stack_data val);
		bool IsEmpty();
		bool ReadTop(stack_data& val);
		bool Pop();
		bool ReadPop(stack_data& val);

	private:
		p_stack_data _p;
		size_t _top;
		size_t _capacity;
	};
}

wind::stack::stack(size_t sz, p_stack_data pArr)
{
    _capacity = sz;
    if (pArr == nullptr)
    {
        p_stack_data p = (p_stack_data)realloc(nullptr, sizeof(stack_data) * _capacity);
        if (p == nullptr)
        {
            perror("wind::stack::stack realloc fail");
            exit(-1);
        }
        _p = p;
        _top = 0;
    }
    else
    {
        _p = pArr;
        _top = _capacity;
    }
}
```

这里用`exit`主要是考虑到构造函数都失败了，意味着实例化失败了，所以程序没有必要继续运行了。

测试一下：打印会干扰测试影响观感，所以注释掉了。

```cpp
#include"stack.h"
#include<time.h>

#define N 1000000

void test1()
{
	clock_t begin = clock();
	auto p = (wind::p_stack_data)malloc(sizeof(wind::stack_data) * N);
	if (p == nullptr)
	{
		perror("test1 malloc fail");
		return;
	}
	int i = 0;
	for (; i < N; i++)
	{
		p[i] = i + 1;
	}
	wind::stack s(N, p);
	/*while (!s.IsEmpty())
	{
		wind::stack_data i;
		s.ReadPop(i);
		std::cout << i << " ";
	}
	std::cout << std::endl;*/
	s.Dest();
	clock_t end = clock();
	std::cout << end - begin << "ms" << std::endl;
}

void test2()
{
	clock_t begin = clock();
	wind::stack s;
	int i = 0;
	for (; i < N; i++)
	{
		s.push(i + 1);
	}
	/*while (!s.IsEmpty())
	{
		wind::stack_data i;
		s.ReadPop(i);
		std::cout << i << " ";
	}
	std::cout << std::endl;*/
	s.Dest();
	clock_t end = clock();
	std::cout << end - begin << "ms" << std::endl;
}

int main()
{
	test1();
	test2();
	return 0;
}
```

![image-20240925152504972](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409251525206.png)

-----------

好的，下面我们来看一看，编译器自己生成的构造函数有什么特点

第一个特点，在开头就已经提到，如果我们写了默认函数，不管写的怎么样，对不对，编译器都不会再自动生成了，而是用用户写的。此外，编译器自动生成的构造函数没有显式参数。可以实验一下

```cpp
// 注释掉之前写的构造函数，运行下列代码，可以编译通过
int main()
{
	wind::Date d;
	return 0;
}

// 现在取消之前构造函数的注释，并把它设置成非缺省函数
namespace wind
{
	class Date
	{
	public:
		Date(int year, int month, int day);
		//Date(int year = 1, int month = 1, int day = 1);
		void Init(int year, int month, int day);
		void Print();
	private:
		int _year;
		int _month;
		int _day;
	};
}

wind::Date::Date(int year, int month, int day)
{
	_year = year;
	_month = month;
	_day = day;
}

// 再此运行相同代码，无法编译通过
// error C2512: “wind::Date”: 没有合适的默认构造函数可用
```

第二个特点，对于内置类型的成员变量，编译器自己生成的构造函数不一定会对其初始化，有些新的编译器可能会将其初始化为0

```cpp
#include"Date.h"
// 已经注释了自己的构造函数
int main()
{
	wind::Date d;
	d.Print();
	return 0;
}
```

![image-20240925154914464](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409251549640.png)

看来我是旧的那种。没有进行任何处理，打印出的值还是栈帧开辟时的初始数据。

后来C++标准委员会意识到这样做不太好，所以在C++11后，引入了为类中成员变量设置缺省值的语法

```cpp
namespace wind
{
	class Date
	{
	public:
		//Date(int year = 1, int month = 1, int day = 1);
		void Init(int year, int month, int day);
		void Print();
	private:
		int _year = 1;
		int _month = 1;
		int _day = 1;
	};
}
```

![image-20240925155505147](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202409251555249.png)

对于自定义类型的成员变量，编译器自动生成的构造函数会做初始化，怎么初始化呢？它会调用这个自定义类型的构造函数。这个怎么实验呢？学数据结构的时候，好像有个题目：两个栈实现一个队列

```cpp
#pragma once
#include"stack.h"

namespace wind
{
	class Queue
	{
	public:

	private:
		stack PushStack;
		stack PopStack;
	};
}

#include"queue.h"

int main()
{
	wind::Queue q;
	return 0;
}
```

```assembly
	wind::Queue q;
00007FF68F58262E  mov         edx,30h  
00007FF68F582633  lea         rcx,[q]  
00007FF68F582637  call        wind::Queue::__autoclassinit2 (07FF68F5811F9h)  
00007FF68F58263C  lea         rcx,[q]  
00007FF68F582640  call        wind::Queue::Queue (07FF68F581154h)  
00007FF68F582645  nop  
/////////////

00007FF68F581154  jmp         wind::Queue::Queue (07FF68F582540h)  
//////////

00007FF68F582540  mov         qword ptr [rsp+8],rcx  
00007FF68F582545  push        rbp  
00007FF68F582546  push        rdi  
00007FF68F582547  sub         rsp,0E8h  
00007FF68F58254E  lea         rbp,[rsp+20h]  
00007FF68F582553  mov         rax,qword ptr [this]  
00007FF68F58255A  xor         r8d,r8d  
00007FF68F58255D  mov         edx,4  
00007FF68F582562  mov         rcx,rax  
00007FF68F582565  call        wind::stack::stack (07FF68F5813EDh)  
00007FF68F58256A  nop  
00007FF68F58256B  mov         rax,qword ptr [this]  
00007FF68F582572  add         rax,18h  
00007FF68F582576  xor         r8d,r8d  
00007FF68F582579  mov         edx,4  
00007FF68F58257E  mov         rcx,rax  
00007FF68F582581  call        wind::stack::stack (07FF68F5813EDh)  
00007FF68F582586  nop  
```

那如果此时`stack`我们自己没写构造函数怎么办，那就用编译器自己生成的构造函数。要注意的是自己写`stack`构造函数的时候，如果构造函数不设置为全缺省函数的话，因为没有给参数，所以`Queue`就无法实例化,因此，如果构造函数自己写的话，要将其设置为全缺省函数或者像编译器自己生成的那样没有参数。

```shell
error C2280: “wind::Queue::Queue(void)”: 尝试引用已删除的函数
```

所以当类中成员变量有自定义类型的时候，用编译器自动生成的构造函数反而更好。

构造函数还有些东西，但我们暂时先不说。

#### 析构函数

析构函数的函数名是"~className"，也就是取反号加上构造函数名，所以析构函数的名字暗含着反向构造函数的意思；它的主要职责是把对象中动态开辟的空间释放掉；如果说构造函数是半自动函数的话——对象实例化时被调用，因此用户有传参的可能，析构函数就是全自动函数，它会在对象生命周期结束后自动调用，所以用户完全没办法传参，因此，构造函数不仅没有返回值（没有`void`），就连参数（显式的）也一个没有，既然它没有参数，自然改变不了参数顺序，所以没有重载的用法。和构造函数一样，如果用户不写析构函数，编译器就会自动生成析构函数，对于成员变量中的内置类型，自动生成的析构函数不会对它们做任何处理，因为对象生命周期已经结束了，这些成员变量会随着函数栈帧的释放一起释放，对于成员变量中的自定义类型，它会去调用对应的析构函数。

```cpp
namespace wind
{
	typedef int stack_data, * p_stack_data;
	class stack
	{
	public:
		stack(size_t sz = 4, p_stack_data pArr = nullptr);
		~stack();
		void Ext();
		void push(stack_data val);
		bool IsEmpty();
		bool ReadTop(stack_data& val);
		bool Pop();
		bool ReadPop(stack_data& val);

	private:
		p_stack_data _p;
		size_t _top;
		size_t _capacity;
	};
}

wind::stack::~stack()
{
    free(_p);
    _p = nullptr;
    _top = _capacity = 0;
}
```



# 完