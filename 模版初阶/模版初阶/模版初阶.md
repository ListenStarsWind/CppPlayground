# 模版初阶

## 泛型编程

C++中的函数作为某一过程的实现方式，常常会遇到这种困扰：两个函数的逻辑十分相似，不过由于函数的参数必须指定类型，所以必须拆成两个函数写，尽管C++c存在重载函数，函数名可以相同，但还是要一个一个写，太麻烦了，此时模版就可以发挥作用了。

```cpp
// 如何实现一个通用的交换函数呢？
void Swap(int& left, int& right)
{
	int temp = left;
	left = right;
	right = temp;
}
void Swap(double& left, double& right)
{
	double temp = left;
	left = right;
	right = temp;
}
void Swap(char& left, char& right)
{
	char temp = left;
	left = right;
	right = temp;
}
// ······
```

模版的使用方法是关键字`template<class name>`或者`template<typename name>`，其中的`name`是对类型的代称。名字怎么取都行，能表现具体用途的更好。多个类型是这样的`template<class T1, class T2>`。

```cpp
//template<typename v>
template<class v>
void Swap(v& val1, v& val2)
{
	auto temp = val1;
	val1 = val2;
	val2 = temp;
}
```

当调用模版函数时，编译器会依据参数的类型和函数模版生成一份对应的函数。

```cpp
int main()
{
	int i = 1, j = 10;
	double m = 1.25, n = 6.25;
	Swap(i, j);
	Swap(m, n);
	return 0;
}
```

![image-20241010141340672](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410101413766.png)

![image-20241010141730853](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410101417025.png)

函数可以有模版，类也可以有。对于各种数据结构来说，有时需要存储不同类型的数据，比如，我们想生成一个用来存储整型和浮点型的栈，此时类模版就非常有用，`typedef`则要再写一份。

```cpp
typedef int SDate, * pSDate;
class Stack
{
public:
	Stack(size_t sz = 4, SDate* pArr = nullptr);
	~Stack();
	Stack(const Stack& s);
	Stack& operator=(const Stack& s);
	void Push(int val);
	void Extend();
	void Print()const;
private:
	SDate* _val;
	size_t _top;
	size_t _capacity;
};
```

```cpp
template<class SDate>
class Stack
{
public:
	Stack(size_t sz = 4, SDate* pArr = nullptr);
	~Stack();
	Stack(const Stack& s);
	Stack& operator=(const Stack& s);
	void Push(int val);
	void Extend();
	void Print()const;
private:
	SDate* _val;
	size_t _top;
	size_t _capacity;
};
```

```cpp
int main()
{
	Stack<int> i;
	Stack<double> j;
	return 0;
}
```

这里没有传参，所以要显式的告诉编译器到底用什么类型，此时的`Stack<int>`和`Stack<double>`实际上已经是两个不同的类了。

-------------

当发生冲突时，就需要显式地调用模版，或者通过类型强转调整参数类型

```cpp
template<class T>
T add(const T& val1, const T& val2)
{
	return val1 + val2;
}

int main()
{
	double i = add<double>(6, 1.25);
	int j = add(6,(int)1.25);
	std::cout << i << std::endl;
	std::cout << j << std::endl;
	return 0;
}
```

![image-20241010150521213](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410101505348.png)

# 完